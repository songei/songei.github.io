<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java类加载机制]]></title>
    <url>%2F2018%2F03%2F14%2Fjavaload%2F</url>
    <content type="text"><![CDATA[1.什么是类的加载类的加载是指将编译完成的字节码文件即class文件中的二进制数据读入内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 2.什么时候进行类加载jvm可以实现预加载功能，类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范规定JVM可以预测加载一个类，如果这个类出错，但是应用程序没有调用这个类， JVM也不会报错；如果调用这个类的话，JVM才会报错。 3.类的生命周期 前五个阶段为类的加载过程，其中加载、验证、准备、初始化四个阶段开始顺序是确定的，而解析阶段可能发生在初始化之后，这是为了支持java动态绑定。而前五个阶段是按顺序开始的，通常这些阶段会交叉进行，通常在一个阶段执行过程中调用或激活另一个阶段。 3.1加载JVM需要完成三件事情 类加载器通过类的全路径限定名读取类的二进制字节流 将二进制字节流代表的类结构转化到运行时数据区的方法区中 在堆中生成代表这个类的java.lang.Class实例，作为对方法区数据访问入口 3.2验证加载和验证是交叉进行的，验证的主要目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段非常重要但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 3.3准备准备是为类静态变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。 进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为：public static int i = 2；i在准备阶段过后的初始值为0，而不是2，因为这时候尚未开始执行任何Java方法，而把value赋值为2的public static指令是在程序编译后，存放于类构造器（）方法之中的，所以把i赋值为2的动作将在初始化阶段才会执行。 如果类字段的字段属性即同时被final和static修饰，那么在准备阶段变量value就会被初始化为属性所指定的值。 类变量i被定义为： public static final int i = 3；编译时Javac将会为i生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。 3.4解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 3.5初始化初始化类的静态变量和静态代码块为用户自定义的值，在类被Java程序“第一次主动使用”的时候，才会触发初始化操作。其中包括： new了一个类的对象 main方法所在类 调用了类的静态成员和静态方法 修改类的静态成员的值 使用java.lang.reflect包对类进行反射调用 初始化子类时，父类未被调用，则先初始化父类 4.类加载器JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系如下：继承关系可通过以下程序验证：12345678public class Main&#123; public static void main(String[] args) &#123; ClassLoader loader = Thread.currentThread().getContextClassLoader(); System.out.println(loader); System.out.println(loader.getParent()); System.out.println(loader.getParent().getParent()); &#125;&#125; 输出 sun.misc.Launcher$AppClassLoader@135fbaa4sun.misc.Launcher$ExtClassLoader@2503dbd3null 注： ExtClassLoader的父类为null，是因为BootStrap ClassLoader使用C语言实现的。 Bootstrap ClassLoader 负责加载$JAVA_HOME中 jre/lib/rt.jar 里所有的class或Xbootclassoath选项指定的jar包。由C++实现，不是ClassLoader子类。 Extension ClassLoader 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。 App ClassLoader 负责加载classpath中指定的jar包及 Djava.class.path 所指定目录下的类和jar包。 User ClassLoader 通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。 JVM类加载机制 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 双亲委派模型如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader```去完成。 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载； 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。 结束生命周期在如下几种情况下，Java虚拟机将结束生命周期 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring访问多个不同数据库]]></title>
    <url>%2F2018%2F03%2F12%2Fconnecttwodatabase%2F</url>
    <content type="text"><![CDATA[在使用Spring开发时，配置单一数据库是非常容易的，但同时访问多个数据库不可避免，本文使用Spring boot简化配置多数据库源。 搭建两个数据库 Mysql5.7 123456789CREATE DATABASE mysqlsample;USE DATABASE mysqlsample;CREATE TABLE usermaster ( id int(11) NOT NULL PRIMARY KEY , name varchar(255) DEFAULT NULL, email varchar(20) DEFAULT NULL, phone varchar(20) DEFAULT NULL);INSERT INTO usermaster VALUE(&apos;1&apos;,&apos;tom&apos;,&apos;mysql@mysql.com&apos;,&apos;1234567890&apos;) PostgreSQL 10 12345678CREATE TABLE usermaster ( id integer PRIMARY KEY , name character varying, email character varying, phone character varying(10));INSERT INTO usermaster(id, name, email, phone)VALUES (1, &apos;john&apos;, &apos;postgresql@postgresql.com&apos;, &apos;1234567890&apos;); 使用IDEa搭建项目pom.xml如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.properties如下 123456789server.port=8080#指定第一个数据源postgresqlfirst.datasource.jdbc-url=jdbc:postgresql://localhost:5432/postgresfirst.datasource.driver-class-name=org.postgresql.Driver#指定第二个数据源mysqlsecond.datasource.jdbc-url = jdbc:mysql://localhost:3306/mysqlsamplesecond.datasource.username = rootsecond.datasource.password = Tyrion568&amp;second.datasource.driver-class-name=com.mysql.jdbc.Driver first.datasource为PostgreSQL定义的属性second.datasource为mysql定义的属性 DBConfig.java 123456789101112131415161718192021222324252627282930313233343536373839404142import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;/** * @author Song Wei * @description * @date 12/03/2018 14:47 */@Configurationpublic class DBConfig &#123; @Bean(name = "mysqlDB") @Primary @ConfigurationProperties(prefix = "second.datasource") public DataSource mysqlDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Primary @Bean(name = "mysqlJdbcTemplate") @Autowired public JdbcTemplate jdbcTemplate(@Qualifier("mysqlDB") DataSource dsMySQL) &#123; return new JdbcTemplate(dsMySQL); &#125; @Bean(name = "postgresDB") @ConfigurationProperties(prefix = "first.datasource") public DataSource postgresDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = "postgresJdbcTemplate") @Autowired public JdbcTemplate postgresJdbcTemplate(@Qualifier("postgresDB") DataSource dsPostgres) &#123; return new JdbcTemplate(dsPostgres); &#125;&#125; 第一个Bean注解创建mysqlDB bean第二个ConfigurationProperties注解加载所有前缀为spring.ds_mysql的属性随后创建并初始化DataSource并创建了MysqlDB DataSource对象Qualifier以创建的mysqlDB为qualifier并用DataSource对象初始化JdbcTemplate实例随后初始化postgresql template DemoController.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.example.demo.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Map;/** * @author Song Wei * @description * @date 12/03/2018 14:59 */@RestControllerpublic class DemoController &#123; @Autowired @Qualifier("postgresJdbcTemplate") private JdbcTemplate postgresTemplate; @Autowired @Qualifier("mysqlJdbcTemplate") private JdbcTemplate mysqlTemplate; @GetMapping(value = "/getPostgresUser") public String getPostgreUser()&#123; Map&lt;String, Object&gt; map = new HashMap(); String query = "select * from usermaster"; try &#123; map = postgresTemplate.queryForMap(query); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return "PostgreSQL : " + map.toString(); &#125; @RequestMapping(value = "/getMysqlUser") public String getMysqlUser() &#123; Map&lt;String, Object&gt; map = new HashMap(); String query = "select * from usermaster"; try &#123; map = mysqlTemplate.queryForMap(query); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return "MySQL : " + map.toString(); &#125;&#125; 运行程序访问地址URL1：http://localhost:8080/getPostgresUser URL2：http://localhost:8080/getPostgresUser]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的null]]></title>
    <url>%2F2018%2F03%2F11%2Fnull%2F</url>
    <content type="text"><![CDATA[1.null是java中的关键字，像public、static、void。大小写敏感，Null或NULL都是错误的，编译器不能识别。12Object object = Null; //wrongObject object = null; //ok 2.在java中的每一种基本类型都有默认值，int默认值为0，boolean默认值是false，任何引用类型变量的默认值都是null(所有变量都是如此，如成员变量、局部变量、实例变量、静态变量)。1234private static Object object;public static void main(String args[])&#123; System.out.print("The value of object is:" + object);&#125; 输出：The value of object is:null 3.null既不是对象也不是类型，而仅仅是一种特殊值，可以将null赋予任何引用类型，也可以将null转换成任何类型。1234567String s = null; //okFloat f = null; //okObject o = null; //okString s = (String)null; //okFloat f = (Float)null; //okObject o = (Object)null; //ok 4.null可以赋值给给引用变量，你不能将null赋给基本类型变量，例如int、double、float、boolean。如果你那样做了，编译器将会报错。但是如果将null赋值给包装类object，然后将object赋给各自的基本类型，编译器不会报，但是你将会在运行时期遇到空指针异常,这是Java中的自动拆箱导致的。123456int i = null; //wrongfloat f = null; //wrongdouble d = null; //wrongInteger i = null; //okint j = i; //ok 5.任何含有null值的包装类在Java拆箱生成基本数据类型时候都会抛出一个空指针异常。在使用HashMap和Integer键值的时候会发生很多这样的错误。1234567891011121314import java.util.HashMap;import java.util.Map;public class Test &#123; public static void main(String args[]) throws InterruptedException &#123; Map numberAndCount = new HashMap&lt;&gt;(); int[] numbers = &#123;3, 5, 7,9, 11, 13, 17, 19, 2, 3, 5, 33, 12, 5&#125;; for(int i : numbers)&#123; int count = numberAndCount.get(i); numberAndCount.put(i, count++); // NullPointerException here &#125; &#125;&#125; 输出：Exception in thread “main” java.lang.NullPointerException at Test.main(Test.java:12) 6.如果使用了带有null值的引用类型变量，instanceof操作将会返回false1234567891011public class Main&#123; public static void main(String[] args)&#123; Integer i = null; if(i instanceof Integer)&#123; System.out.println("i is instance of Integer"); &#125;else&#123; System.out.println("i is not an instance of Integer"); &#125; &#125;&#125; 输出：i is not an instance of Integer 7.值为null的引用类型变量调用非静态方法会抛出空指针异常，但是值为null的引用类型变量可以调用静态方法而不会抛出异常，因为静态方法使用静态绑定，不会抛出空指针异常。12345678910111213public class Main&#123; public static void main(String[] args)&#123; Main m = null; m.staticMethod(); m.noneStaticMethod(); &#125; private static void staticMethod()&#123; System.out.println("static can be called by null reference"); &#125; private void noneStaticMethod()&#123; System.out.println("none static can not be called by null reference"); &#125;&#125; I am static method, can be called by null referenceException in thread “main” java.lang.NullPointerException at Testing.main(Testing.java:4) 注：java1.8及其以上已经禁止实例变量调用静态方法 8.可以将null传递给方法使用，这时方法可以接收任何引用类型，例如public void print(Object obj)可以这样调用print(null)。从编译角度来看这是可以的，但结果完全取决于方法。Null安全的方法，如在这个例子中的print方法，不会抛出空指针异常，只是优雅的退出。如果业务逻辑允许的话，推荐使用null安全的方法。9.可以使用==或者!=操作来比较null值，但是不能使用其他算法或者逻辑操作，例如小于或者大于。跟SQL不一样，在Java中null==null将返回true。1234567891011public class Main&#123; public static void main(String[] args) &#123; Object object1 = null; Object object2 = null; if (object1 == object2)&#123; System.out.println("null == null is true"); &#125;else &#123; System.out.println("null == null is false"); &#125; &#125;&#125; 输出：null == null is true]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeoptimization]]></title>
    <url>%2F2018%2F03%2F07%2Fcodeoptimization%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[java集合关系总结图]]></title>
    <url>%2F2018%2F03%2F07%2Fcollection%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux grep命令]]></title>
    <url>%2F2018%2F03%2F07%2Fgrep%2F</url>
    <content type="text"><![CDATA[简介 1grep(Global Search Regular Expression And Print Out The Line)是Linux，Unix文本搜索工具，利用正则表达式匹配搜索文本，并把匹配的行打印出来 格式 1grep 参数 files 主要参数 12345678910|参数|描述||:-:|:-:||-i|不区分大小写||-c|只输出匹配行的数目||-n|显示匹配行及行号||-s|不显示错误信息||-v|反向匹配，显示不匹配的行||-l|查询多文件时候只输出包含匹配字符的文件名||-r|递归查找子目录||--color|将关键字加上颜色| 常用正则表达式 123456789|参数|描述||:-:|:-:||\|反义字符||^$|开始和结束||[]|单个字符||-|匹配范围字符||*|前面字符出现零次或者多次||+|前面字符出现一次或者多次||.|任意字符| 使用场景 1234567891011121314151617**不区分大小写，加上-i来忽略大小写*** 在文本中搜索一个单词grep pattern filename在filename文件中查找所有匹配pattern的单词`* 在多个文件中查找grep pattern filename1 filename2 ...在多个文件中查找所有匹配pattern的单词`* 使用-v反向输出，显示不匹配的行grep -v pattern filename* 标记匹配颜色grep pattern filename --color* 使用-c统计个数grep -c pattern filename* 使用-r递归查找子目录grep -r pattern directorydirectory .表示当前目录]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql中DATE_FORMAT用法]]></title>
    <url>%2F2018%2F01%2F07%2Fdateformat%2F</url>
    <content type="text"><![CDATA[DATE_FORMAT(date,format)根据fromat字符串参数格式化日期format参数需加百分号表示参数例：12SELECT DATE_FORMAT(&apos;2017-1-7 10:45:23&apos;,&apos;%Y-%c-%e&apos;);2017-1-7 参数 描述 %a 周英文缩写(Sun,Mon..Sat) %b 月数英文缩写(Jan,Feb..Dec) %c 月数数字(0,1..12) %D 带英文尾缀的一月中天数(0th,1st,2nd,3rd..) %d 一月中天数数字格式(00..31) %e 一月中天数数字格式(0..31) %f 日期的毫秒数(000000..999999) %H 一天中小时数24小时制(00..23) %h 一天中小时数12小时制(01..12) %I 一天中小时数12小时制(01..12) %i 一小时的分钟数(00..59) %j 一年中天数(001..366) %k 一天中小时数24小时制(0..23) %l 一天中小时数12小时制(1..12) %M 月数英文全称(January..December) %m 月数数字(00..12) %p AM PM %r 12小时制时间(hh:mm:ss加AM PM) %S 秒数(00..59) %s 秒数(00..59) %T 24小时制时间(hh:mm:ss) %U 一年中周数(00..53),周日是一周的头一天 %u 一年中周数(00..53),周一是一周的头一天 %W 一周天数英文全称(Sunday..Saturday) %w 一周天数数字(0=Sunday..6=Saturday) %Y 年数，四位数(2017) %y 年数，二位数(17) 12345678910按年统计select 列 from 表 group by date_format(列,&apos;%Y&apos;);按月统计select 列 from 表 group by date_format(列,&apos;%Y-%c&apos;);按周统计select 列 from 表 group by date_format(列,&apos;%Y-%u&apos;);按天统计select 列 from 表 group by date_format(列,&apos;%Y-%c-%e&apos;);按小时统计select 列 from 表 group by date_format(列,&apos;%Y-%c-%e %H&apos;);]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 yum错误cannot find a valid baseurl for repo:base/7/x86_64]]></title>
    <url>%2F2017%2F12%2F18%2Fyumerror%2F</url>
    <content type="text"><![CDATA[问题主要原因是无法联网，解决方法 方法1 vim /etc/sysconfig/network-scripts/ifcfg-eth0（端口可能会不一致，数字会有变化） onboot=no改为onboot=yes 重启网络 service network restart 方法2 vim /etc/resolv.conf 添加nameserver 8.8.8.8 重启网络 service network restart]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux shutdown命令]]></title>
    <url>%2F2017%2F12%2F14%2Fshutdown%2F</url>
    <content type="text"><![CDATA[shutdown命令 参数 含义用法 -t 参数后加秒数，代表过几秒后关机 -k 并不关机，只是发送警告消息 -r 在关掉系统服务之后 重启 -h 在关掉系统服务之后 关机 -n 不经过init程序，直接以shutdown来关机 -f 关机重启后，强制略过fsck磁盘检查 -F 关机重启后，强制进行fsck磁盘检查 -c 取消已经在进行的shutdown命令内容 时间 指定系统关机时间 例: 1234567891011121314shutdown -h now立刻关机，now相当于时间为0shutdown -h +20在二十分钟后关机shutdown -r +20在二十分钟后重启shutdown -k now 'the system will rebot'系统不会关闭，只是发消息给所有用户通知shutdown -h 20:20在晚上20:20关机 注：除使用图形界面，可以以任何身份关机其余例如远程ssh服务都需要root权限]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot实现文件上传下载]]></title>
    <url>%2F2017%2F12%2F08%2FfileUpDown%2F</url>
    <content type="text"><![CDATA[前端前端使用html的form表单实现文件上传method设置为post，并将enctype设置为multipart/form-data部分html代码： 1234&lt;form th:action="/upload" method="POST" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" /&gt; &lt;input type="submit" value="click to upload" /&gt;&lt;/form&gt; /upload对应后端接口 文件上传文件处理controller12345678910111213@Controllerpublic class FileController &#123; //自定义文件处理服务类 @Autowired private FileServiceImpl fileService; /** *文件上传 */ @RequestMapping(value = "/upload",method = RequestMethod.POST) public String upload(@RequestParam("file") MultipartFile file) &#123; return fileService.uploadFile(file); &#125;&#125; 定义fileService类处理上传12345678910111213141516171819202122232425262728293031323334353637383940@Servicepublic class FileService&#123; /** * 文件上传处理函数 */ public String uploadFile(MultipartFile file) &#123; //判断文件是否为空 if (file.isEmpty()) &#123; return "Empty"; &#125; //文件名 String fileName = file.getOriginalFilename(); //文件的保存路径 自定义可单独写个类 String filePath = "/Users/Songie/"; //文件最终的存储位置 File dest = new File(filePath + fileName); //判断目标文件所在的目录是否存在 if(!dest.getParentFile().exists()) &#123; //如果目标文件所在的目录不存在，则创建父目录 System.out.println("文件所处目录不存在，创建"); //创建目录 if(!dest.getParentFile().mkdirs()) &#123; System.out.println("创建文件所处目录失败！"); return "fail"; &#125; &#125; //如果文件所在目录存在 try &#123; //存储文 file.transferTo(dest); return "success"; &#125; catch (IllegalStateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return "fail"; &#125;&#125; 文件下载前端1&lt;a href="/download/文件名"&gt;下载&lt;/a&gt; controller中的下载方法1234567/** * 文件下载 */@RequestMapping("/download/&#123;fileName&#125;")public String downloadFile(@PathVariable("fileName") String fileName,HttpServletRequest request, HttpServletResponse response)&#123; return fileService.downloadFile(fileName,request,response);&#125; 定义fileService类处理下载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 文件下载处理函数 */public String downloadFile(fileName,HttpServletRequest request, HttpServletResponse response)&#123; //文件的保存路径 自定义可单独写个类 String filePath = "/Users/Songie/"; File file = new File(filePath, fileName); //如果文件存在 if (file.exists()) &#123; //重置buffer response.resetBuffer(); //设定编码为UTF-8 response.setCharacterEncoding("UTF-8"); //设置头部为下载信息 response.setHeader("Content-type","application/force-download;charset=UTF-8"); try &#123; response.setHeader("content-disposition", "attachment;filename=" + URLEncoder.encode(fileName, "UTF-8"));// 设置文件名 &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; //各种流信息 FileInputStream fileInputStream = null; BufferedInputStream bufferedInputStream = null; OutputStream outputStream = null; try &#123; byte[] buffer = new byte[1024]; fileInputStream = new FileInputStream(file); bufferedInputStream = new BufferedInputStream(fileInputStream); outputStream=response.getOutputStream(); int i = bufferedInputStream.read(buffer); while (i != -1) &#123; outputStream.write(buffer, 0, i); i = bufferedInputStream.read(buffer); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭各种流 if (outputStream != null)&#123; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (bufferedInputStream!= null) &#123; try &#123; bufferedInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (fileInputStream != null) &#123; try &#123; fileInputStream.close(); return "success"; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;//finally结束 &#125;//if结束 return "fail";&#125;//downloadFile结束 注：若想限制文件上传大小，需要在application.properties中配置参数 123spring.http.multipart.enabled=truespring.http.multipart.max-file-size=60MBspring.http.multipart.max-request-size=60MB]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot继承Spring Security实现权限认证]]></title>
    <url>%2F2017%2F12%2F05%2Fauthorize%2F</url>
    <content type="text"><![CDATA[1.在pom中添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 2.编写WebSecurity配置类，继承WebSecurityConfigurerAdapter类，重写configure方法1.开启表单验证12345678910@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .anyRequest().authenticated()//确保所有请求都需要被验证 .and() .formLogin()//基于表单方式登录验证 .loginPage("/login") //指定登录页面 .permitAll(); //formLogin().permitAll()方法允许基于表单登录的所有的URL的所有用户的访问&#125; 2.开启验证请求1234567891011121314151617@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .antMatchers("/resources/**", "/signup", "/about").permitAll() //在resources下的所有资源，signup，about都可以访问 .antMatchers("/admin/**").hasRole("ADMIN") //以 "/admin/" 开头的URL只能由拥有 "ROLE_ADMIN"角色的用户访问 .antMatchers("/db/**").access("hasRole('ADMIN') and hasRole('DBA')")//任何以"/db/" 开头的URL需要用户同时具有 "ROLE_ADMIN" 和 "ROLE_DBA" .anyRequest().authenticated() .and() .rememberMe().key(“www.songwei.site”) //启用记住我,key中需要指定参数为网址 .and().sessionManagement().maximumSessions(1).expiredUrl("/login?expired").sessionRegistry(sessionRegistry()); //启用单点登录，session最大为1，如果再次登录销毁之前的session // ... .formLogin();&#125;@Beanpublic SessionRegistry sessionRegistry()&#123; return new SessionRegistryImpl();&#125; 3.处理退出默认是访问的路径是/logout将注销登陆的用户： 使HTTP Session 无效 清楚所有已经配置的 RememberMe 认证 清除SecurityContextHolder 跳转到 /login?logout 123456789101112protected void configure(HttpSecurity http) throws Exception &#123; http .logout() .logoutUrl("/my/logout") //自定义logout退出界面 .logoutSuccessUrl("/my/index") //如果退出成功跳转到index .logoutSuccessHandler(logoutSuccessHandler) //自定义退出成功的处理类 ，如果指定了这个选项那么logoutSuccessUrl()的设置会被忽略 .invalidateHttpSession(true) //抹除session .addLogoutHandler(logoutHandler) //添加一个LogoutHandler，默认SecurityContextLogoutHandler会被添加为最后一个LogoutHandler .deleteCookies(cookieNamesToClear) //退出登录时候擦书cookie .and() ...&#125; 4.基于jdbc的验证方式123456789101112@Autowiredprivate DataSource dataSource;@Autowiredpublic void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; auth .jdbcAuthentication() .dataSource(dataSource) .withDefaultSchema() .withUser("user").password("password").roles("USER").and() .withUser("admin").password("password").roles("USER", "ADMIN");&#125; 也可以自定义一个AuthenticationProvider，UserDetailsService为bean定义自定义身份验证 123456789101112131415161718192021222324252627282930313233343536373839/** * 设置密码加密方式用BCrpt加密算法 */@Autowiredprivate PasswordEncoder passwordEncoder;@Beanpublic PasswordEncoder passwordEncoder()&#123;return new BCryptPasswordEncoder();&#125;@BeanUserDetailsService buildUserDetailsService() &#123; return username-&gt; &#123; //自定一个的用户类，其中有用户名和密码 User user = userDao.getUserByUserNickname(username); //返回UserDetailsService org.springframework.security.core.userdetails.User userService=new org.springframework.security.core.userdetails.User( user.getUserNickname(), user.getUserPassword(), true, true, true, true, AuthorityUtils.createAuthorityList("USER", "write")); return userService; &#125;;&#125; @Beanpublic AuthenticationProvider authenticationProvider()&#123; DaoAuthenticationProvider provider = new DaoAuthenticationProvider(); provider.setUserDetailsService(buildUserDetailsService());//设置UserDetailsService provider.setPasswordEncoder(passwordEncoder);//设置加密方式 return provider;&#125;@Autowiredpublic void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; auth.authenticationProvider(authenticationProvider());&#125; 3.添加注解123456789101112131415@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)//使用@EnableGlobalMethodSecurity注解来启用基于注解的安全性//在方法上添加注解，进行权限拦截认证等public interface BankService &#123; @PreAuthorize("isAnonymous()") public Account readAccount(Long id); @PreAuthorize(value = "principal.username.equals(#username)") public Account[] findAccounts(); @PreAuthorize("hasAuthority('ROLE_TELLER')") public Account post(Account account, double amount);&#125; @EnableGlobalMethodSecurity 可以配置多个参数:prePostEnabled :决定Spring Security的注解[@PreAuthorize,@PostAuthorize,..] 是否可用secureEnabled : 决定是否Spring Security的保障注解 [@Secured] 是否可用jsr250Enabled ：决定 JSR-250 annotations 注解[@RolesAllowed..] 是否可用 具体请参考：Spring security5.0.0官方手册Spring security5.0.0官方Api]]></content>
      <tags>
        <tag>spring security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql5.7创建用户开放远程连接]]></title>
    <url>%2F2017%2F12%2F04%2Fconnect%2F</url>
    <content type="text"><![CDATA[1.执行mysql命令输入密码后进入mysql1mysql -u root -p 2.选择mysql数据库1use mysql; 3.创建用户1create user '用户名'@'%' identified by '密码'; 用户名自行填写%代表所有地址，也可指定具体地址，例如localhost,全文皆以%代替注：密码需要满足mysql密码策略，详情见centos7忘记mysql密码 4.用户授权1grant all privileges on 数据库名.* to '用户名'@'%' identified by '密码' with grant option; 权限可自定义权限例如： grant select, insert on ….等数据库名.*代表此数据库下的所有表，也可指定到此数据库下具体的表 5.刷新权限1234567flush privileges;```` ### 6.修改用户密码 ```shell set password for '用户名'@'%' = password('新密码'); 7.查看用户权限1show grants for 用户名@%; 8.撤销用户权限1revoke all privileges on 数据库名.表 from '用户名'@'%'; 9.删除用户1drop user '用户名'@'%';]]></content>
  </entry>
  <entry>
    <title><![CDATA[centos7忘记mysql密码]]></title>
    <url>%2F2017%2F12%2F04%2Ffogetmysqlpassword%2F</url>
    <content type="text"><![CDATA[##个人环境 mysql 5.7.16 centos 7.4 1.修改mysql配置文件编辑配置文件 1vim /etc/my.cnf 按i在[mysqld]中添加skip-grant-tables,即跳过权限认证 1skip-grant-tables 按esc后输入:wq保存退出 2.重启mysql输入命令重启 1service mysqld restart 3.登录mysql1mysql -u root -p 无需输入密码直接回车进入mysql 4.修改mysql的root密码选择mysql数据库 1use mysql; 修改root密码 (密码需要满足mysql的密码策略，见底部) 1update user set authentication_string=password('你的密码') where user='root'; 刷新权限 1flush privileges; 退出mysql 1quit; 5.修改/etc/my.cnf 删除skip-grant-tables6.重启mysql1service mysqld restart 7.再次登录mysql，出现错误提示ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.修改密码即可 1set password=password("密码"); 密码策略如下： 至少8位 至少包含1位特殊字符 至少包含大小写混合 至少1位数字如果出现1819错误，代表密码不符合要求ERROR 1819 (HY000): Your password does not satisfy the current policy requirements]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot备份远程阿里云mysql数据库]]></title>
    <url>%2F2017%2F12%2F03%2FdatabaseBackup%2F</url>
    <content type="text"><![CDATA[个人环境 Windows10 mysql 已配置环境变量（将mysql的bin目录添加至环境变量） 阿里云mysql 开启开放远程连接权限 （参考：mysql5.7.20开放远程数据库连接） 定义数据库辅助类存放所需信息 1234567891011121314151617public class DatabaseBackUtil &#123; /** * 数据库备份的部分命令参数 * mysqldump 数据库备份命令 * h 主机地址可以本地或者远端 * P 端口3306 * u 用户名 * p 密码 * 字符集编码 * 最后 数据库名 */ public final static String BACKUP_COMMAND = "mysqldump -h远程或本地数据库地址 -P3306 -u用户 -p密码 --default-character-set=utf8 数据库名"; //数据库恢复部分命令参数 public static final String RECOVER_COMMAND="mysql -h远程或本地数据库地址 -P3306 -u用户 -p密码 --default-character-set=utf8 shop"; //数据库备份的地址 public final static String BACKUP_PATH = "D://back.mysql";&#125; 定义数据库备份恢复服务类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116@Service public class DatabaseBackupService&#123; //备份函数 public static int backup()&#123; //定义所需输入流输出流 StringBuffer stringBuffer = new StringBuffer(); InputStream inputStream = null; InputStreamReader inputStreamReader = null; BufferedReader bufferedReader = null; FileOutputStream fileOutputStream = null; OutputStreamWriter outputStreamWriter = null; try&#123; Runtime runtime = Runtime.getRuntime(); //执行命令行命令 Process process = runtime.exec(DatabaseBackUtil.BACKUP_COMMAND); //获取输入流 inputStream = process.getInputStream(); inputStreamReader = new InputStreamReader(inputStream,"utf8"); bufferedReader = new BufferedReader(inputStreamReader); //写入到buffer中 while ((s=bufferedReader.readLine())!=null)&#123; stringBuffer.append(s+"\r\n"); &#125; //写入到SQL文件中 File file = new File(DatabaseBackUtil.BACKUP_PATH); //设置fileOutputStream参数false,即每次写入覆盖掉到之前的备份 fileOutputStream = new FileOutputStream(BACKUP_PATH,false); //为防止乱码 设置outputStreamWriter为utf8 outputStreamWriter = new OutputStreamWriter(fileOutputStream,"utf8"); outputStreamWriter.write(stringBuffer.toString()); outputStreamWriter.flush(); &#125;catch (IOException e) &#123; //如果获取失败 返回-1 return -1; &#125; finally &#123; try &#123; //关闭各种流 fileOutputStream.close(); bufferedReader.close(); inputStreamReader.close(); inputStream.close(); //如果成功，返回0 return 0; &#125;catch (IOException e)&#123; return -1; &#125; &#125; &#125; //恢复备份函数 public int recover()&#123; //各种流 OutputStream outputStream = null; StringBuffer stringBuffer = new StringBuffer(); InputStreamReader inputStreamReader = null; BufferedReader bufferedReader = null; FileInputStream fileInputStream = null; OutputStreamWriter outputStreamWriter = null; try &#123; Runtime runtime = Runtime.getRuntime(); Process process = runtime.exec(DatabaseBackUtil.RECOVER_COMMAND); outputStream = process.getOutputStream(); fileInputStream = new FileInputStream(DatabasePath.BACKUP_PATH); inputStreamReader = new InputStreamReader(fileInputStream); bufferedReader = new BufferedReader(inputStreamReader); stringBuffer = new StringBuffer(); while ((s=bufferedReader.readLine())!=null)&#123; stringBuffer.append(s+"\r\n"); &#125; outputStreamWriter = new OutputStreamWriter(outputStream,"utf8"); outputStreamWriter.write(stringBuffer.toString()); outputStreamWriter.flush(); &#125; catch (IOException e) &#123; return -1; &#125; finally &#123; try &#123; outputStreamWriter.close(); bufferedReader.close(); inputStreamReader.close(); fileInputStream.close(); outputStream.close(); return 0; &#125;catch (IOException e)&#123; return -1; &#125; &#125; &#125; &#125; ``` 3. 定义数据库定时类```java@Componentpublic class DatabaseBackupScheduler &#123; private final static Logger logger = LoggerFactory.getLogger(DatabaseBackupScheduler.class); /** * &lt;p&gt;Description: 每天3点备份一次&lt;/p &gt; * @param * @return * @exception */ @Scheduled(cron = "0 0 3 * * ?") public void backupInSchedule()&#123; DatabaseBackupService.backup(); logger.info("备份成功"+new Date().toString()); &#125;&#125; 开启多线程 （参考:Spring Boot使用@Schedule注解开启定时任务） mysql详细参数 参数 含义 –user, -u 用户名 –password, -p 数据库密码 –port, -P 数据库端口号 –default-character-set 默认字符集，默认值为utf8 –host, -h 主机地址 –databases, -B 导出数据库。可将多个数据库跟在参数后 –force 在导出过程中忽略出现的SQL错误 –events, -E 导出事件 –debug 输出debug信息，用于调试。默认值为：d:t:o,/tmp/mysqldump.trace –debug-info 输出调试信息并退出 –flush-privileges 在导出mysql数据库之后，发FLUSH PRIVILEGES 语句 –no-data, -d 不导出任何数据，只导出数据库表结构 –no-create-info, -t 只导出数据，而不添加CREATE TABLE 语句 –no-create-db, -n 只导出数据，而不添加CREATE DATABASE 语句 –ignore-table 忽略导出指定表。指定忽略多个表时，需要重复多次，每次一个表，每个表必须同时指定数据库和表 –lock-tables, -l 开始导出前，锁定所有表 –all-databases , -A 导出全部数据库 –all-tablespaces , -Y 导出全部表空间 –no-tablespaces , -y 不导出任何表空间 –add-drop-database 数据库创建之前 添加drop数据库的语句 –add-drop-table 数据表创建之前 添加drop数据表的语句（可使用–skip-add-drop-table取消该选项） –add-locks 在每个表导出之前增加LOCK TABLES并且之后UNLOCK TABLE。默认为打开状态，使用–skip-add-locks取消选项 –lock-all-tables, -x 提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭 –comments 附加注释信息，可以用–skip-comments取消 –compact 导出更少的输出信息(用于调试)。去掉注释和头尾等结构 –complete-insert, -c 使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败 –compress, -C 在客户端和服务器之间启用压缩传递所有信息 –delayed-insert 采用延时插入方式导出数据]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot使用@Schedule注解开启定时任务]]></title>
    <url>%2F2017%2F12%2F03%2FScheduler%2F</url>
    <content type="text"><![CDATA[在Application类上开启EnableScheduling注解 123456789101112131415161718192021222324252627282930@SpringBootApplication @EnableSchedulingpublic class Application&#123; public static void main(String[] args)&#123; SpringApplication.run(Application.class,args); &#125;&#125;``` 2.创建一个任务类并在方法上开启@Scheduled注解```java@Componentpublic class DatabaseBackupScheduler &#123; private final static Logger logger = LoggerFactory.getLogger(DatabaseBackupScheduler.class); @Scheduled(cron = "0 0/1 * * * ?") public void cronSchedule()&#123; logger.info("cron每一分钟执行一次"); &#125; @Scheduled(fixedRate = 60000) public void fixedRateSchedule()&#123; logger.info("fixedRate每一分钟执行一次"); &#125; @Scheduled(fixedDelay = 60000) public void fixedDealyInSchedule()&#123; logger.info("fixedDealy每一分钟执行一次"); &#125;&#125; 以上三种方式都是每分钟执行一次注解方法 fixedRate是每间隔一段时间执行一次 fixedDelay是在任务执行完成后的一段时间开始执行 在上述方法中 fixedRate是每60秒执行一次，无论任务执行了多久都必须强制执行 fixedDelay是在任务执行完成后60秒在执行 cron表达式可用于实现复杂定时任务 语法格式为： Seconds Minutes Hours DayofMonth Month DayofWeek Year Seconds Minutes Hours DayofMonth Month DayofWeek 简单语法 格式 取值范围 可出现字符 秒 0~59 , - * / 分 0~59 , - * / 时 0~23 , - * / 天/月 0~31 , - * / ? L W C 月 0~11 , - * / 天/周 1~7 , - * / ? L C # 年 1970~2099 , - * / 注：在天/周中，1=SUN ，2=MON，3=TUE，4=WED，5=THU，6=FRI，7=SAT 字符 含义 例 * 每多少的意思 Minutes中使用*，表示每分钟触发 - 间隔，表示范围 Minutes使用10-20,表示10-20每分钟触发 / 起始时间触发，每隔固定时间触发一次 Minutes使用10/20,表示10分钟触发一次，然后30分钟触发一次，50分钟触发一次 , 列出触发的时间 Minutes使用10,20 表示在10分钟和20分钟触发一次 ？ 只能用于天/月，天/周两个字段 DayofMonth和DayofWeek是两个相互排斥的元素，通过问号来表明不指定值,例如在每月的10日触发调度，不管10日到底是星期几，只能写例如:13 13 15 10 ?, 最后一位只能用？，而不能使用 ，如果使用*表示不管星期几都会触发,两者互斥 例如 0 0 10,20 ? ： 每天上午10点,晚上八点触发 0 20 10 ? ： 每天上午10:20触发 0 20 10 ? * MON-FRI ： 周一至周五的上午10:20触发 开启多线程模式Springboot本身默认的@EnableScheduling注解执行方式是串行执行，即无论有多少任务，都是一个线程串行执行，并行多线程需手动配置配置类如下： @Configuration @EnableScheduling public class ShedulingConfig implements SchedulingConfigurer{ @Override public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) { cheduledTaskRegistrar.setScheduler(scheduler()); } @Bean public ThreadPoolTaskScheduler scheduler() { ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setPoolSize(20); scheduler.setThreadNamePrefix("task-"); scheduler.setAwaitTerminationSeconds(60); scheduler.setWaitForTasksToCompleteOnShutdown(true); return scheduler; } }]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
</search>
