<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java中的null]]></title>
    <url>%2F2018%2F03%2F11%2Fnull%2F</url>
    <content type="text"><![CDATA[###1.null是java中的关键字，像public、static、void。大小写敏感，Null或NULL都是错误的，编译器不能识别。 12Object object = Null; //wrongObject object = null; //ok ###2.在java中的每一种基本类型都有默认值，int默认值为0，boolean默认值是false，任何引用类型变量的默认值都是null(所有变量都是如此，如成员变量、局部变量、实例变量、静态变量)。 1234private static Object object;public static void main(String args[])&#123; System.out.print("The value of object is:" + object);&#125; 输出：The value of object is:null ###3.null既不是对象也不是类型，而仅仅是一种特殊值，可以将null赋予任何引用类型，也可以将null转换成任何类型。 1234567String s = null; //okFloat f = null; //okObject o = null; //okString s = (String)null; //okFloat f = (Float)null; //okObject o = (Object)null; //ok ###4.null可以赋值给给引用变量，你不能将null赋给基本类型变量，例如int、double、float、boolean。如果你那样做了，编译器将会报错。但是如果将null赋值给包装类object，然后将object赋给各自的基本类型，编译器不会报，但是你将会在运行时期遇到空指针异常,这是Java中的自动拆箱导致的。 123456int i = null; //wrongfloat f = null; //wrongdouble d = null; //wrongInteger i = null; //okint j = i; //ok ###5.任何含有null值的包装类在Java拆箱生成基本数据类型时候都会抛出一个空指针异常。在使用HashMap和Integer键值的时候会发生很多这样的错误。 1234567891011121314import java.util.HashMap;import java.util.Map;public class Test &#123; public static void main(String args[]) throws InterruptedException &#123; Map numberAndCount = new HashMap&lt;&gt;(); int[] numbers = &#123;3, 5, 7,9, 11, 13, 17, 19, 2, 3, 5, 33, 12, 5&#125;; for(int i : numbers)&#123; int count = numberAndCount.get(i); numberAndCount.put(i, count++); // NullPointerException here &#125; &#125;&#125; 输出：Exception in thread “main” java.lang.NullPointerException at Test.main(Test.java:12) ###6.如果使用了带有null值的引用类型变量，instanceof操作将会返回false 1234567891011public class Main&#123; public static void main(String[] args)&#123; Integer i = null; if(i instanceof Integer)&#123; System.out.println("i is instance of Integer"); &#125;else&#123; System.out.println("i is not an instance of Integer"); &#125; &#125;&#125; 输出：i is not an instance of Integer ###7.值为null的引用类型变量调用非静态方法会抛出空指针异常，但是值为null的引用类型变量可以调用静态方法而不会抛出异常，因为静态方法使用静态绑定，不会抛出空指针异常。 12345678910111213public class Main&#123; public static void main(String[] args)&#123; Main m = null; m.staticMethod(); m.noneStaticMethod(); &#125; private static void staticMethod()&#123; System.out.println("static can be called by null reference"); &#125; private void noneStaticMethod()&#123; System.out.println("none static can not be called by null reference"); &#125;&#125; I am static method, can be called by null referenceException in thread “main” java.lang.NullPointerException at Testing.main(Testing.java:4) 注：java1.8及其以上已经禁止实例变量调用静态方法 ###8.可以将null传递给方法使用，这时方法可以接收任何引用类型，例如public void print(Object obj)可以这样调用print(null)。从编译角度来看这是可以的，但结果完全取决于方法。Null安全的方法，如在这个例子中的print方法，不会抛出空指针异常，只是优雅的退出。如果业务逻辑允许的话，推荐使用null安全的方法。 ###9.可以使用==或者!=操作来比较null值，但是不能使用其他算法或者逻辑操作，例如小于或者大于。跟SQL不一样，在Java中null==null将返回true。 1234567891011public class Main&#123; public static void main(String[] args) &#123; Object object1 = null; Object object2 = null; if (object1 == object2)&#123; System.out.println("null == null is true"); &#125;else &#123; System.out.println("null == null is false"); &#125; &#125;&#125; 输出：null == null is true]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeoptimization]]></title>
    <url>%2F2018%2F03%2F07%2Fcodeoptimization%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[java集合关系总结图]]></title>
    <url>%2F2018%2F03%2F07%2Fcollection%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux grep命令]]></title>
    <url>%2F2018%2F03%2F07%2Fgrep%2F</url>
    <content type="text"><![CDATA[简介 1grep(Global Search Regular Expression And Print Out The Line)是Linux，Unix文本搜索工具，利用正则表达式匹配搜索文本，并把匹配的行打印出来 格式 1grep 参数 files 主要参数 12345678910|参数|描述||:-:|:-:||-i|不区分大小写||-c|只输出匹配行的数目||-n|显示匹配行及行号||-s|不显示错误信息||-v|反向匹配，显示不匹配的行||-l|查询多文件时候只输出包含匹配字符的文件名||-r|递归查找子目录||--color|将关键字加上颜色| 常用正则表达式 123456789|参数|描述||:-:|:-:||\|反义字符||^$|开始和结束||[]|单个字符||-|匹配范围字符||*|前面字符出现零次或者多次||+|前面字符出现一次或者多次||.|任意字符| 使用场景 1234567891011121314151617**不区分大小写，加上-i来忽略大小写*** 在文本中搜索一个单词grep pattern filename在filename文件中查找所有匹配pattern的单词`* 在多个文件中查找grep pattern filename1 filename2 ...在多个文件中查找所有匹配pattern的单词`* 使用-v反向输出，显示不匹配的行grep -v pattern filename* 标记匹配颜色grep pattern filename --color* 使用-c统计个数grep -c pattern filename* 使用-r递归查找子目录grep -r pattern directorydirectory .表示当前目录]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql中DATE_FORMAT用法]]></title>
    <url>%2F2018%2F01%2F07%2Fdateformat%2F</url>
    <content type="text"><![CDATA[DATE_FORMAT(date,format)根据fromat字符串参数格式化日期format参数需加百分号表示参数例：12SELECT DATE_FORMAT(&apos;2017-1-7 10:45:23&apos;,&apos;%Y-%c-%e&apos;);2017-1-7 参数 描述 %a 周英文缩写(Sun,Mon..Sat) %b 月数英文缩写(Jan,Feb..Dec) %c 月数数字(0,1..12) %D 带英文尾缀的一月中天数(0th,1st,2nd,3rd..) %d 一月中天数数字格式(00..31) %e 一月中天数数字格式(0..31) %f 日期的毫秒数(000000..999999) %H 一天中小时数24小时制(00..23) %h 一天中小时数12小时制(01..12) %I 一天中小时数12小时制(01..12) %i 一小时的分钟数(00..59) %j 一年中天数(001..366) %k 一天中小时数24小时制(0..23) %l 一天中小时数12小时制(1..12) %M 月数英文全称(January..December) %m 月数数字(00..12) %p AM PM %r 12小时制时间(hh:mm:ss加AM PM) %S 秒数(00..59) %s 秒数(00..59) %T 24小时制时间(hh:mm:ss) %U 一年中周数(00..53),周日是一周的头一天 %u 一年中周数(00..53),周一是一周的头一天 %W 一周天数英文全称(Sunday..Saturday) %w 一周天数数字(0=Sunday..6=Saturday) %Y 年数，四位数(2017) %y 年数，二位数(17) 12345678910按年统计select 列 from 表 group by date_format(列,&apos;%Y&apos;);按月统计select 列 from 表 group by date_format(列,&apos;%Y-%c&apos;);按周统计select 列 from 表 group by date_format(列,&apos;%Y-%u&apos;);按天统计select 列 from 表 group by date_format(列,&apos;%Y-%c-%e&apos;);按小时统计select 列 from 表 group by date_format(列,&apos;%Y-%c-%e %H&apos;);]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 yum错误cannot find a valid baseurl for repo:base/7/x86_64]]></title>
    <url>%2F2017%2F12%2F18%2Fyumerror%2F</url>
    <content type="text"><![CDATA[问题主要原因是无法联网，解决方法 方法1 vim /etc/sysconfig/network-scripts/ifcfg-eth0（端口可能会不一致，数字会有变化） onboot=no改为onboot=yes 重启网络 service network restart 方法2 vim /etc/resolv.conf 添加nameserver 8.8.8.8 重启网络 service network restart]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux shutdown命令]]></title>
    <url>%2F2017%2F12%2F14%2Fshutdown%2F</url>
    <content type="text"><![CDATA[shutdown命令 参数 含义用法 -t 参数后加秒数，代表过几秒后关机 -k 并不关机，只是发送警告消息 -r 在关掉系统服务之后 重启 -h 在关掉系统服务之后 关机 -n 不经过init程序，直接以shutdown来关机 -f 关机重启后，强制略过fsck磁盘检查 -F 关机重启后，强制进行fsck磁盘检查 -c 取消已经在进行的shutdown命令内容 时间 指定系统关机时间 例: 1234567891011121314shutdown -h now立刻关机，now相当于时间为0shutdown -h +20在二十分钟后关机shutdown -r +20在二十分钟后重启shutdown -k now 'the system will rebot'系统不会关闭，只是发消息给所有用户通知shutdown -h 20:20在晚上20:20关机 注：除使用图形界面，可以以任何身份关机其余例如远程ssh服务都需要root权限]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot实现文件上传下载]]></title>
    <url>%2F2017%2F12%2F08%2FfileUpDown%2F</url>
    <content type="text"><![CDATA[前端前端使用html的form表单实现文件上传method设置为post，并将enctype设置为multipart/form-data部分html代码： 1234&lt;form th:action="/upload" method="POST" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" /&gt; &lt;input type="submit" value="click to upload" /&gt;&lt;/form&gt; /upload对应后端接口 文件上传文件处理controller12345678910111213@Controllerpublic class FileController &#123; //自定义文件处理服务类 @Autowired private FileServiceImpl fileService; /** *文件上传 */ @RequestMapping(value = "/upload",method = RequestMethod.POST) public String upload(@RequestParam("file") MultipartFile file) &#123; return fileService.uploadFile(file); &#125;&#125; 定义fileService类处理上传12345678910111213141516171819202122232425262728293031323334353637383940@Servicepublic class FileService&#123; /** * 文件上传处理函数 */ public String uploadFile(MultipartFile file) &#123; //判断文件是否为空 if (file.isEmpty()) &#123; return "Empty"; &#125; //文件名 String fileName = file.getOriginalFilename(); //文件的保存路径 自定义可单独写个类 String filePath = "/Users/Songie/"; //文件最终的存储位置 File dest = new File(filePath + fileName); //判断目标文件所在的目录是否存在 if(!dest.getParentFile().exists()) &#123; //如果目标文件所在的目录不存在，则创建父目录 System.out.println("文件所处目录不存在，创建"); //创建目录 if(!dest.getParentFile().mkdirs()) &#123; System.out.println("创建文件所处目录失败！"); return "fail"; &#125; &#125; //如果文件所在目录存在 try &#123; //存储文 file.transferTo(dest); return "success"; &#125; catch (IllegalStateException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return "fail"; &#125;&#125; 文件下载前端1&lt;a href="/download/文件名"&gt;下载&lt;/a&gt; controller中的下载方法1234567/** * 文件下载 */@RequestMapping("/download/&#123;fileName&#125;")public String downloadFile(@PathVariable("fileName") String fileName,HttpServletRequest request, HttpServletResponse response)&#123; return fileService.downloadFile(fileName,request,response);&#125; 定义fileService类处理下载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 文件下载处理函数 */public String downloadFile(fileName,HttpServletRequest request, HttpServletResponse response)&#123; //文件的保存路径 自定义可单独写个类 String filePath = "/Users/Songie/"; File file = new File(filePath, fileName); //如果文件存在 if (file.exists()) &#123; //重置buffer response.resetBuffer(); //设定编码为UTF-8 response.setCharacterEncoding("UTF-8"); //设置头部为下载信息 response.setHeader("Content-type","application/force-download;charset=UTF-8"); try &#123; response.setHeader("content-disposition", "attachment;filename=" + URLEncoder.encode(fileName, "UTF-8"));// 设置文件名 &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; //各种流信息 FileInputStream fileInputStream = null; BufferedInputStream bufferedInputStream = null; OutputStream outputStream = null; try &#123; byte[] buffer = new byte[1024]; fileInputStream = new FileInputStream(file); bufferedInputStream = new BufferedInputStream(fileInputStream); outputStream=response.getOutputStream(); int i = bufferedInputStream.read(buffer); while (i != -1) &#123; outputStream.write(buffer, 0, i); i = bufferedInputStream.read(buffer); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭各种流 if (outputStream != null)&#123; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (bufferedInputStream!= null) &#123; try &#123; bufferedInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (fileInputStream != null) &#123; try &#123; fileInputStream.close(); return "success"; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;//finally结束 &#125;//if结束 return "fail";&#125;//downloadFile结束 注：若想限制文件上传大小，需要在application.properties中配置参数 123spring.http.multipart.enabled=truespring.http.multipart.max-file-size=60MBspring.http.multipart.max-request-size=60MB]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot继承Spring Security实现权限认证]]></title>
    <url>%2F2017%2F12%2F05%2Fauthorize%2F</url>
    <content type="text"><![CDATA[1.在pom中添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 2.编写WebSecurity配置类，继承WebSecurityConfigurerAdapter类，重写configure方法1.开启表单验证12345678910@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .anyRequest().authenticated()//确保所有请求都需要被验证 .and() .formLogin()//基于表单方式登录验证 .loginPage("/login") //指定登录页面 .permitAll(); //formLogin().permitAll()方法允许基于表单登录的所有的URL的所有用户的访问&#125; 2.开启验证请求1234567891011121314151617@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .antMatchers("/resources/**", "/signup", "/about").permitAll() //在resources下的所有资源，signup，about都可以访问 .antMatchers("/admin/**").hasRole("ADMIN") //以 "/admin/" 开头的URL只能由拥有 "ROLE_ADMIN"角色的用户访问 .antMatchers("/db/**").access("hasRole('ADMIN') and hasRole('DBA')")//任何以"/db/" 开头的URL需要用户同时具有 "ROLE_ADMIN" 和 "ROLE_DBA" .anyRequest().authenticated() .and() .rememberMe().key(“www.songwei.site”) //启用记住我,key中需要指定参数为网址 .and().sessionManagement().maximumSessions(1).expiredUrl("/login?expired").sessionRegistry(sessionRegistry()); //启用单点登录，session最大为1，如果再次登录销毁之前的session // ... .formLogin();&#125;@Beanpublic SessionRegistry sessionRegistry()&#123; return new SessionRegistryImpl();&#125; 3.处理退出默认是访问的路径是/logout将注销登陆的用户： 使HTTP Session 无效 清楚所有已经配置的 RememberMe 认证 清除SecurityContextHolder 跳转到 /login?logout 123456789101112protected void configure(HttpSecurity http) throws Exception &#123; http .logout() .logoutUrl("/my/logout") //自定义logout退出界面 .logoutSuccessUrl("/my/index") //如果退出成功跳转到index .logoutSuccessHandler(logoutSuccessHandler) //自定义退出成功的处理类 ，如果指定了这个选项那么logoutSuccessUrl()的设置会被忽略 .invalidateHttpSession(true) //抹除session .addLogoutHandler(logoutHandler) //添加一个LogoutHandler，默认SecurityContextLogoutHandler会被添加为最后一个LogoutHandler .deleteCookies(cookieNamesToClear) //退出登录时候擦书cookie .and() ...&#125; 4.基于jdbc的验证方式123456789101112@Autowiredprivate DataSource dataSource;@Autowiredpublic void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; auth .jdbcAuthentication() .dataSource(dataSource) .withDefaultSchema() .withUser("user").password("password").roles("USER").and() .withUser("admin").password("password").roles("USER", "ADMIN");&#125; 也可以自定义一个AuthenticationProvider，UserDetailsService为bean定义自定义身份验证 123456789101112131415161718192021222324252627282930313233343536373839/** * 设置密码加密方式用BCrpt加密算法 */@Autowiredprivate PasswordEncoder passwordEncoder;@Beanpublic PasswordEncoder passwordEncoder()&#123;return new BCryptPasswordEncoder();&#125;@BeanUserDetailsService buildUserDetailsService() &#123; return username-&gt; &#123; //自定一个的用户类，其中有用户名和密码 User user = userDao.getUserByUserNickname(username); //返回UserDetailsService org.springframework.security.core.userdetails.User userService=new org.springframework.security.core.userdetails.User( user.getUserNickname(), user.getUserPassword(), true, true, true, true, AuthorityUtils.createAuthorityList("USER", "write")); return userService; &#125;;&#125; @Beanpublic AuthenticationProvider authenticationProvider()&#123; DaoAuthenticationProvider provider = new DaoAuthenticationProvider(); provider.setUserDetailsService(buildUserDetailsService());//设置UserDetailsService provider.setPasswordEncoder(passwordEncoder);//设置加密方式 return provider;&#125;@Autowiredpublic void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; auth.authenticationProvider(authenticationProvider());&#125; 3.添加注解123456789101112131415@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)//使用@EnableGlobalMethodSecurity注解来启用基于注解的安全性//在方法上添加注解，进行权限拦截认证等public interface BankService &#123; @PreAuthorize("isAnonymous()") public Account readAccount(Long id); @PreAuthorize(value = "principal.username.equals(#username)") public Account[] findAccounts(); @PreAuthorize("hasAuthority('ROLE_TELLER')") public Account post(Account account, double amount);&#125; @EnableGlobalMethodSecurity 可以配置多个参数:prePostEnabled :决定Spring Security的注解[@PreAuthorize,@PostAuthorize,..] 是否可用secureEnabled : 决定是否Spring Security的保障注解 [@Secured] 是否可用jsr250Enabled ：决定 JSR-250 annotations 注解[@RolesAllowed..] 是否可用 具体请参考：Spring security5.0.0官方手册Spring security5.0.0官方Api]]></content>
      <tags>
        <tag>spring security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql5.7创建用户开放远程连接]]></title>
    <url>%2F2017%2F12%2F04%2Fconnect%2F</url>
    <content type="text"><![CDATA[1.执行mysql命令输入密码后进入mysql1mysql -u root -p 2.选择mysql数据库1use mysql; 3.创建用户1create user '用户名'@'%' identified by '密码'; 用户名自行填写%代表所有地址，也可指定具体地址，例如localhost,全文皆以%代替注：密码需要满足mysql密码策略，详情见centos7忘记mysql密码 4.用户授权1grant all privileges on 数据库名.* to '用户名'@'%' identified by '密码' with grant option; 权限可自定义权限例如： grant select, insert on ….等数据库名.*代表此数据库下的所有表，也可指定到此数据库下具体的表 5.刷新权限1234567flush privileges;```` ### 6.修改用户密码 ```shell set password for '用户名'@'%' = password('新密码'); 7.查看用户权限1show grants for 用户名@%; 8.撤销用户权限1revoke all privileges on 数据库名.表 from '用户名'@'%'; 9.删除用户1drop user '用户名'@'%';]]></content>
  </entry>
  <entry>
    <title><![CDATA[centos7忘记mysql密码]]></title>
    <url>%2F2017%2F12%2F04%2Ffogetmysqlpassword%2F</url>
    <content type="text"><![CDATA[##个人环境 mysql 5.7.16 centos 7.4 1.修改mysql配置文件编辑配置文件 1vim /etc/my.cnf 按i在[mysqld]中添加skip-grant-tables,即跳过权限认证 1skip-grant-tables 按esc后输入:wq保存退出 2.重启mysql输入命令重启 1service mysqld restart 3.登录mysql1mysql -u root -p 无需输入密码直接回车进入mysql 4.修改mysql的root密码选择mysql数据库 1use mysql; 修改root密码 (密码需要满足mysql的密码策略，见底部) 1update user set authentication_string=password('你的密码') where user='root'; 刷新权限 1flush privileges; 退出mysql 1quit; 5.修改/etc/my.cnf 删除skip-grant-tables6.重启mysql1service mysqld restart 7.再次登录mysql，出现错误提示ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.修改密码即可 1set password=password("密码"); 密码策略如下： 至少8位 至少包含1位特殊字符 至少包含大小写混合 至少1位数字如果出现1819错误，代表密码不符合要求ERROR 1819 (HY000): Your password does not satisfy the current policy requirements]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot备份远程阿里云mysql数据库]]></title>
    <url>%2F2017%2F12%2F03%2FdatabaseBackup%2F</url>
    <content type="text"><![CDATA[个人环境 Windows10 mysql 已配置环境变量（将mysql的bin目录添加至环境变量） 阿里云mysql 开启开放远程连接权限 （参考：mysql5.7.20开放远程数据库连接） 定义数据库辅助类存放所需信息 1234567891011121314151617public class DatabaseBackUtil &#123; /** * 数据库备份的部分命令参数 * mysqldump 数据库备份命令 * h 主机地址可以本地或者远端 * P 端口3306 * u 用户名 * p 密码 * 字符集编码 * 最后 数据库名 */ public final static String BACKUP_COMMAND = "mysqldump -h远程或本地数据库地址 -P3306 -u用户 -p密码 --default-character-set=utf8 数据库名"; //数据库恢复部分命令参数 public static final String RECOVER_COMMAND="mysql -h远程或本地数据库地址 -P3306 -u用户 -p密码 --default-character-set=utf8 shop"; //数据库备份的地址 public final static String BACKUP_PATH = "D://back.mysql";&#125; 定义数据库备份恢复服务类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116@Service public class DatabaseBackupService&#123; //备份函数 public static int backup()&#123; //定义所需输入流输出流 StringBuffer stringBuffer = new StringBuffer(); InputStream inputStream = null; InputStreamReader inputStreamReader = null; BufferedReader bufferedReader = null; FileOutputStream fileOutputStream = null; OutputStreamWriter outputStreamWriter = null; try&#123; Runtime runtime = Runtime.getRuntime(); //执行命令行命令 Process process = runtime.exec(DatabaseBackUtil.BACKUP_COMMAND); //获取输入流 inputStream = process.getInputStream(); inputStreamReader = new InputStreamReader(inputStream,"utf8"); bufferedReader = new BufferedReader(inputStreamReader); //写入到buffer中 while ((s=bufferedReader.readLine())!=null)&#123; stringBuffer.append(s+"\r\n"); &#125; //写入到SQL文件中 File file = new File(DatabaseBackUtil.BACKUP_PATH); //设置fileOutputStream参数false,即每次写入覆盖掉到之前的备份 fileOutputStream = new FileOutputStream(BACKUP_PATH,false); //为防止乱码 设置outputStreamWriter为utf8 outputStreamWriter = new OutputStreamWriter(fileOutputStream,"utf8"); outputStreamWriter.write(stringBuffer.toString()); outputStreamWriter.flush(); &#125;catch (IOException e) &#123; //如果获取失败 返回-1 return -1; &#125; finally &#123; try &#123; //关闭各种流 fileOutputStream.close(); bufferedReader.close(); inputStreamReader.close(); inputStream.close(); //如果成功，返回0 return 0; &#125;catch (IOException e)&#123; return -1; &#125; &#125; &#125; //恢复备份函数 public int recover()&#123; //各种流 OutputStream outputStream = null; StringBuffer stringBuffer = new StringBuffer(); InputStreamReader inputStreamReader = null; BufferedReader bufferedReader = null; FileInputStream fileInputStream = null; OutputStreamWriter outputStreamWriter = null; try &#123; Runtime runtime = Runtime.getRuntime(); Process process = runtime.exec(DatabaseBackUtil.RECOVER_COMMAND); outputStream = process.getOutputStream(); fileInputStream = new FileInputStream(DatabasePath.BACKUP_PATH); inputStreamReader = new InputStreamReader(fileInputStream); bufferedReader = new BufferedReader(inputStreamReader); stringBuffer = new StringBuffer(); while ((s=bufferedReader.readLine())!=null)&#123; stringBuffer.append(s+"\r\n"); &#125; outputStreamWriter = new OutputStreamWriter(outputStream,"utf8"); outputStreamWriter.write(stringBuffer.toString()); outputStreamWriter.flush(); &#125; catch (IOException e) &#123; return -1; &#125; finally &#123; try &#123; outputStreamWriter.close(); bufferedReader.close(); inputStreamReader.close(); fileInputStream.close(); outputStream.close(); return 0; &#125;catch (IOException e)&#123; return -1; &#125; &#125; &#125; &#125; ``` 3. 定义数据库定时类```java@Componentpublic class DatabaseBackupScheduler &#123; private final static Logger logger = LoggerFactory.getLogger(DatabaseBackupScheduler.class); /** * &lt;p&gt;Description: 每天3点备份一次&lt;/p &gt; * @param * @return * @exception */ @Scheduled(cron = "0 0 3 * * ?") public void backupInSchedule()&#123; DatabaseBackupService.backup(); logger.info("备份成功"+new Date().toString()); &#125;&#125; 开启多线程 （参考:Spring Boot使用@Schedule注解开启定时任务） mysql详细参数 参数 含义 –user, -u 用户名 –password, -p 数据库密码 –port, -P 数据库端口号 –default-character-set 默认字符集，默认值为utf8 –host, -h 主机地址 –databases, -B 导出数据库。可将多个数据库跟在参数后 –force 在导出过程中忽略出现的SQL错误 –events, -E 导出事件 –debug 输出debug信息，用于调试。默认值为：d:t:o,/tmp/mysqldump.trace –debug-info 输出调试信息并退出 –flush-privileges 在导出mysql数据库之后，发FLUSH PRIVILEGES 语句 –no-data, -d 不导出任何数据，只导出数据库表结构 –no-create-info, -t 只导出数据，而不添加CREATE TABLE 语句 –no-create-db, -n 只导出数据，而不添加CREATE DATABASE 语句 –ignore-table 忽略导出指定表。指定忽略多个表时，需要重复多次，每次一个表，每个表必须同时指定数据库和表 –lock-tables, -l 开始导出前，锁定所有表 –all-databases , -A 导出全部数据库 –all-tablespaces , -Y 导出全部表空间 –no-tablespaces , -y 不导出任何表空间 –add-drop-database 数据库创建之前 添加drop数据库的语句 –add-drop-table 数据表创建之前 添加drop数据表的语句（可使用–skip-add-drop-table取消该选项） –add-locks 在每个表导出之前增加LOCK TABLES并且之后UNLOCK TABLE。默认为打开状态，使用–skip-add-locks取消选项 –lock-all-tables, -x 提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭 –comments 附加注释信息，可以用–skip-comments取消 –compact 导出更少的输出信息(用于调试)。去掉注释和头尾等结构 –complete-insert, -c 使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败 –compress, -C 在客户端和服务器之间启用压缩传递所有信息 –delayed-insert 采用延时插入方式导出数据]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot使用@Schedule注解开启定时任务]]></title>
    <url>%2F2017%2F12%2F03%2FScheduler%2F</url>
    <content type="text"><![CDATA[在Application类上开启EnableScheduling注解 123456789101112131415161718192021222324252627282930@SpringBootApplication @EnableSchedulingpublic class Application&#123; public static void main(String[] args)&#123; SpringApplication.run(Application.class,args); &#125;&#125;``` 2.创建一个任务类并在方法上开启@Scheduled注解```java@Componentpublic class DatabaseBackupScheduler &#123; private final static Logger logger = LoggerFactory.getLogger(DatabaseBackupScheduler.class); @Scheduled(cron = "0 0/1 * * * ?") public void cronSchedule()&#123; logger.info("cron每一分钟执行一次"); &#125; @Scheduled(fixedRate = 60000) public void fixedRateSchedule()&#123; logger.info("fixedRate每一分钟执行一次"); &#125; @Scheduled(fixedDelay = 60000) public void fixedDealyInSchedule()&#123; logger.info("fixedDealy每一分钟执行一次"); &#125;&#125; 以上三种方式都是每分钟执行一次注解方法 fixedRate是每间隔一段时间执行一次 fixedDelay是在任务执行完成后的一段时间开始执行 在上述方法中 fixedRate是每60秒执行一次，无论任务执行了多久都必须强制执行 fixedDelay是在任务执行完成后60秒在执行 cron表达式可用于实现复杂定时任务 语法格式为： Seconds Minutes Hours DayofMonth Month DayofWeek Year Seconds Minutes Hours DayofMonth Month DayofWeek 简单语法 格式 取值范围 可出现字符 秒 0~59 , - * / 分 0~59 , - * / 时 0~23 , - * / 天/月 0~31 , - * / ? L W C 月 0~11 , - * / 天/周 1~7 , - * / ? L C # 年 1970~2099 , - * / 注：在天/周中，1=SUN ，2=MON，3=TUE，4=WED，5=THU，6=FRI，7=SAT 字符 含义 例 * 每多少的意思 Minutes中使用*，表示每分钟触发 - 间隔，表示范围 Minutes使用10-20,表示10-20每分钟触发 / 起始时间触发，每隔固定时间触发一次 Minutes使用10/20,表示10分钟触发一次，然后30分钟触发一次，50分钟触发一次 , 列出触发的时间 Minutes使用10,20 表示在10分钟和20分钟触发一次 ？ 只能用于天/月，天/周两个字段 DayofMonth和DayofWeek是两个相互排斥的元素，通过问号来表明不指定值,例如在每月的10日触发调度，不管10日到底是星期几，只能写例如:13 13 15 10 ?, 最后一位只能用？，而不能使用 ，如果使用*表示不管星期几都会触发,两者互斥 例如 0 0 10,20 ? ： 每天上午10点,晚上八点触发 0 20 10 ? ： 每天上午10:20触发 0 20 10 ? * MON-FRI ： 周一至周五的上午10:20触发 开启多线程模式Springboot本身默认的@EnableScheduling注解执行方式是串行执行，即无论有多少任务，都是一个线程串行执行，并行多线程需手动配置配置类如下： @Configuration @EnableScheduling public class ShedulingConfig implements SchedulingConfigurer{ @Override public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) { cheduledTaskRegistrar.setScheduler(scheduler()); } @Bean public ThreadPoolTaskScheduler scheduler() { ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setPoolSize(20); scheduler.setThreadNamePrefix("task-"); scheduler.setAwaitTerminationSeconds(60); scheduler.setWaitForTasksToCompleteOnShutdown(true); return scheduler; } }]]></content>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
</search>
